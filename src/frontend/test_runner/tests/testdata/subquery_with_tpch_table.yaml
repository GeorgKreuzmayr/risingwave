# This file is automatically generated. See `src/frontend/test_runner/README.md` for more information.
- id: create_tables
  sql: |
    CREATE TABLE supplier (
            s_suppkey  INTEGER,
            s_name VARCHAR(25),
            s_address VARCHAR(40),
            s_nationkey INTEGER,
            s_phone VARCHAR(15),
            s_acctbal NUMERIC,
            s_comment VARCHAR(101));

    CREATE TABLE part (
            p_partkey INTEGER,
            p_name VARCHAR(55),
            p_mfgr VARCHAR(25),
            p_brand VARCHAR(10),
            p_type VARCHAR(100),
            p_size INTEGER,
            p_container VARCHAR(10),
            p_retailprice NUMERIC,
            p_comment VARCHAR(23));

    CREATE TABLE partsupp (
            ps_partkey INTEGER,
            ps_suppkey INTEGER,
            ps_availqty INTEGER,
            ps_supplycost NUMERIC,
            ps_comment VARCHAR(199));

    CREATE TABLE customer (
            c_custkey INTEGER,
            c_name VARCHAR(25),
            c_address VARCHAR(40),
            c_nationkey INTEGER,
            c_phone VARCHAR(15),
            c_acctbal NUMERIC,
            c_mktsegment VARCHAR(10),
            c_comment VARCHAR(117));

    CREATE TABLE orders (
            o_orderkey BIGINT,
            o_custkey INTEGER,
            o_orderstatus VARCHAR(1),
            o_totalprice NUMERIC,
            o_orderdate DATE,
            o_orderpriority VARCHAR(15),
            o_clerk VARCHAR(15),
            o_shippriority INTEGER,
            o_comment VARCHAR(79));

    CREATE TABLE lineitem (
            l_orderkey BIGINT,
            l_partkey INTEGER,
            l_suppkey INTEGER,
            l_linenumber INTEGER,
            l_quantity NUMERIC,
            l_extendedprice NUMERIC,
            l_discount NUMERIC,
            l_tax NUMERIC,
            l_returnflag VARCHAR(1),
            l_linestatus VARCHAR(1),
            l_shipdate DATE,
            l_commitdate DATE,
            l_receiptdate DATE,
            l_shipinstruct VARCHAR(25),
            l_shipmode VARCHAR(10),
            l_comment VARCHAR(44));

    CREATE TABLE nation (
            n_nationkey INTEGER,
            n_name VARCHAR(25),
            n_regionkey INTEGER,
            n_comment VARCHAR(152));

    CREATE TABLE region (
            r_regionkey INTEGER,
            r_name VARCHAR(25),
            r_comment VARCHAR(152));
- id: subquery1
  before:
    - create_tables
  sql: |
    select l_shipdate from lineitem where l_partkey in (select p_partkey from part join partsupp on p_partkey = ps_partkey and l_partkey = p_partkey and l_suppkey = ps_suppkey)
  logical_plan: |
    LogicalProject { exprs: [$11] }
      LogicalApply { type: LeftSemi, on: ($2 = $17), correlated_id: 1 }
        LogicalScan { table: lineitem, columns: [_row_id, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
        LogicalProject { exprs: [$1] }
          LogicalJoin { type: Inner, on: ($1 = $11) AND (CorrelatedInputRef { index: 2, correlated_id: 1 } = $1) AND (CorrelatedInputRef { index: 3, correlated_id: 1 } = $12), output_indices: all }
            LogicalScan { table: part, columns: [_row_id, p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment] }
            LogicalScan { table: partsupp, columns: [_row_id, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment] }
  optimized_logical_plan: |
    LogicalJoin { type: LeftSemi, on: ($0 = $5) AND ($0 = $3) AND ($1 = $4), output_indices: [2] }
      LogicalScan { table: lineitem, columns: [l_partkey, l_suppkey, l_shipdate] }
      LogicalJoin { type: Inner, on: ($2 = $3) AND ($1 = $4), output_indices: [0, 1, 2] }
        LogicalJoin { type: Inner, on: ($0 = $3) AND ($1 = $4), output_indices: [0, 1, 2] }
          LogicalJoin { type: Inner, on: ($0 = $2), output_indices: all }
            LogicalAgg { group_key: [$0, $1], aggs: [] }
              LogicalScan { table: lineitem, columns: [l_partkey, l_suppkey] }
            LogicalScan { table: part, columns: [p_partkey] }
          LogicalAgg { group_key: [$0, $1], aggs: [] }
            LogicalScan { table: lineitem, columns: [l_partkey, l_suppkey] }
        LogicalScan { table: partsupp, columns: [ps_partkey, ps_suppkey] }
- id: subquery2
  before:
    - create_tables
  sql: |
    select l_shipdate from lineitem where l_partkey in (select p_partkey from part where l_partkey = p_partkey and p_partkey in (select ps_partkey from partsupp where l_suppkey = ps_suppkey));
  logical_plan: |
    LogicalProject { exprs: [$11] }
      LogicalApply { type: LeftSemi, on: ($2 = $17), correlated_id: 1 }
        LogicalScan { table: lineitem, columns: [_row_id, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
        LogicalProject { exprs: [$1] }
          LogicalFilter { predicate: (CorrelatedInputRef { index: 2, correlated_id: 1 } = $1) }
            LogicalJoin { type: LeftSemi, on: ($1 = $10), output_indices: all }
              LogicalScan { table: part, columns: [_row_id, p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment] }
              LogicalProject { exprs: [$1] }
                LogicalFilter { predicate: (CorrelatedInputRef { index: 3, correlated_id: 1 } = $2) }
                  LogicalScan { table: partsupp, columns: [_row_id, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment] }
  optimized_logical_plan: |
    LogicalJoin { type: LeftSemi, on: ($0 = $5) AND ($0 = $3) AND ($1 = $4), output_indices: [2] }
      LogicalScan { table: lineitem, columns: [l_partkey, l_suppkey, l_shipdate] }
      LogicalJoin { type: LeftSemi, on: ($2 = $5) AND ($0 = $3) AND ($1 = $4), output_indices: all }
        LogicalJoin { type: Inner, on: ($0 = $2), output_indices: all }
          LogicalAgg { group_key: [$0, $1], aggs: [] }
            LogicalScan { table: lineitem, columns: [l_partkey, l_suppkey] }
          LogicalScan { table: part, columns: [p_partkey] }
        LogicalJoin { type: Inner, on: ($1 = $3), output_indices: [0, 1, 2] }
          LogicalAgg { group_key: [$0, $1], aggs: [] }
            LogicalScan { table: lineitem, columns: [l_partkey, l_suppkey] }
          LogicalScan { table: partsupp, columns: [ps_partkey, ps_suppkey] }
- id: subquery2
  before:
    - create_tables
  sql: |
    select l_shipdate from lineitem where l_partkey in (select l_partkey from part where l_partkey = p_partkey);
  logical_plan: |
    LogicalProject { exprs: [$11] }
      LogicalApply { type: LeftSemi, on: ($2 = $17), correlated_id: 1 }
        LogicalScan { table: lineitem, columns: [_row_id, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
        LogicalProject { exprs: [CorrelatedInputRef { index: 2, correlated_id: 1 }] }
          LogicalFilter { predicate: (CorrelatedInputRef { index: 2, correlated_id: 1 } = $1) }
            LogicalScan { table: part, columns: [_row_id, p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment] }
  optimized_logical_plan: |
    LogicalJoin { type: LeftSemi, on: ($0 = $3) AND ($0 = $2), output_indices: [1] }
      LogicalScan { table: lineitem, columns: [l_partkey, l_shipdate] }
      LogicalProject { exprs: [$0, $0] }
        LogicalScan { table: part, columns: [p_partkey] }
